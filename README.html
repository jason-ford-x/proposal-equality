<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  border-radius: 3px;
}

.markdown-body code:not(.highlight):not(.codehilite), .markdown-body samp {
  background-color: rgba(0,0,0,0.04);
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
}

.markdown-body .codehilite,
.markdown-body .highlight,
.markdown-body pre {
  border-radius: 3px;
}

.markdown-body :not(.highlight) > pre {
  background-color: #f7f7f7;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

.markdown-body diagram-div, .markdown-body div.uml-sequence-diagram, .markdown-body, div.uml-flowchart {
  overflow: auto;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#f7f7f7;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>README</title></head><body><article class="markdown-body"><h1 id="equality-api">Equality API<a class="headerlink" href="#equality-api" title="Permanent link"></a></h1>
<h2 id="status">Status<a class="headerlink" href="#status" title="Permanent link"></a></h2>
<p>Champion(s): <em>TBC</em><br />
Author(s): <em>Jason Ford</em><br />
Stage: 0</p>
<h2 id="about">About<a class="headerlink" href="#about" title="Permanent link"></a></h2>
<p>Inspired by an aspect of the <a href="https://github.com/tc39/proposal-composites"><strong>Composites</strong></a> proposal, which <u>requires an algorithm for determining if two data structures are identical</u>. A part of this proposal provides a solution to the same problem space and so thus competes with Composites.</p>
<h2 id="proposal">Proposal<a class="headerlink" href="#proposal" title="Permanent link"></a></h2>
<p>An algorithm that can say if two objects have the same structure could be considered a kind of equality. To provide a standard for this new algorithm and to help developers avoid common issues with <code>==</code> vs <code>===</code>, I am proposing the addition of a top-level <code>Equality</code> API that names these various algorithms and provides powerful utility methods around equality.</p>
<p><u>This proposal takes the form of a library, not a language enhancement</u>; a proper implementation would likely leverage engine internals to be more optimized.</p>
<h2 id="new-equality-uniform">New Equality: &ldquo;Uniform&rdquo;<a class="headerlink" href="#new-equality-uniform" title="Permanent link"></a></h2>
<p>Some other languages allow you to compare objects and know if they are effectively identical, regardless of references. This is not trivial in Javascript; using <code>JSON.stringify()</code> to compare serialized versions of those objects is imperfect and costly.</p>
<p>This proposal includes a recursive algorithm for doing a value/structure comparison between objects, with some nuances and caveats:</p>
<ul>
<li><code>Weak*</code> are skipped entirely — based on their nature, this seems acceptable</li>
<li><code>Symbols</code> are coerced to <code>String</code></li>
<li>The ordering within <code>Object</code> <strong>does not</strong> matter</li>
<li>The ordering within <code>Map</code>/<code>Set</code> <strong>does</strong> matter</li>
<li>Circular references are skipped when encountered in <em>either</em> item, it is <strong>not</strong> checked if they go to the same structure</li>
<li>The algorithm is depth-first and returns as soon as a <em>difference</em> is found. It has various pre-checks to avoid unnecessary work, like strict-equality checking, type-checking, etc.</li>
<li>Considered <em>less strict</em> than <code>==</code> since it returns <code>true</code> in more scenarios than <code>==</code> would</li>
</ul>
<p><em>The algorithm will be available shortly — note that it is written for clarity not performance</em>.</p>
<h2 id="naming">Naming<a class="headerlink" href="#naming" title="Permanent link"></a></h2>
<p>I&rsquo;ve chosen &lsquo;feel&rsquo; based names, as &lsquo;jargon&rsquo; names would likely impeded learning/understanding, and &lsquo;what&rsquo; names that try to convey what is included/excluded are likely to be overloaded. The names chosen are:</p>
<ul>
<li><code>loose</code> for <code>==</code>  </li>
<li><code>strict</code> for <code>===</code>  </li>
<li><code>uniform</code> for <code>~=</code> (<strong>new</strong> - symbol is unnecessary). Uniform as in clothing — uniforms are by design interchangable yet not the same object.</li>
</ul>
<h2 id="api-methods">API Methods<a class="headerlink" href="#api-methods" title="Permanent link"></a></h2>
<p><code>Equality</code> is a new top-level object. All methods below return a <code>Boolean</code> except for those that indicate otherwise.</p>
<h3 id="equalityloose-a-b">Equality.loose( a, b )<a class="headerlink" href="#equalityloose-a-b" title="Permanent link"></a></h3>
<p>Just a <code>return a == b</code> statement;
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">loose</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span> <span class="p">)</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">loose</span><span class="p">(</span> <span class="p">[],</span> <span class="p">[]</span> <span class="p">)</span> <span class="c1">// false</span>
</pre></div></p>
<h3 id="equalitystrict-a-b">Equality.strict( a, b )<a class="headerlink" href="#equalitystrict-a-b" title="Permanent link"></a></h3>
<p>Just a <code>return a === b</code> statement;
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">strict</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span> <span class="p">)</span> <span class="c1">// false</span>

<span class="kd">let</span> <span class="nx">a</span><span class="o">=</span><span class="nx">b</span><span class="o">=</span><span class="p">[]</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">strict</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">)</span> <span class="c1">// true</span>
</pre></div></p>
<h3 id="equalityuniform-a-b-depthinfinity">Equality.uniform( a, b, depth=Infinity )<a class="headerlink" href="#equalityuniform-a-b-depthinfinity" title="Permanent link"></a></h3>
<p>Uses the proposed <code>uniform</code> algorithm. The depth parameter is like <code>Array.flat</code>, where for nested objects it sets the maximum depth to travel before returning a result. Depth cannot be <code>&lt;1</code> and defaults to <code>Infinity</code>, as I imagine most would want to compare the entire object.
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">uniform</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">uniform</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">)</span> <span class="c1">// false</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">uniform</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1">// true</span>
</pre></div></p>
<h3 id="equalitytest-a-b-methodrequired">Equality.test( a, b, method:required )<a class="headerlink" href="#equalitytest-a-b-methodrequired" title="Permanent link"></a></h3>
<p>Allows you to specify the equality method as an argument (string or method reference) rather than using the named method. This can be more convenient in certain situations with spread syntax and such.
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;loose&#39;</span> <span class="p">);</span> <span class="c1">// vs Equality.loose( 1, &#39;1&#39; )</span>
</pre></div></p>
<h3 id="equalityof-a-b-methodoptional-string-or-boolean">Equality.of( a, b, method:optional ) :: String or Boolean<a class="headerlink" href="#equalityof-a-b-methodoptional-string-or-boolean" title="Permanent link"></a></h3>
<p>If <code>method</code> is not provided, this will return the name of the most strict equality found between <code>a</code> and <code>b</code>, otherwise returns <code>none</code>.
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>               <span class="c1">// &#39;strict&#39;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">);</span>             <span class="c1">// &#39;loose&#39;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>               <span class="c1">// &#39;none&#39;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">([</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]);</span>           <span class="c1">// &#39;uniform&#39;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span><span class="nx">myObj</span><span class="p">);</span>       <span class="c1">// &#39;strict&#39;</span>
</pre></div></p>
<p>When <code>method</code> is provided, it will assert it against the result, returning a Boolean.
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="s1">&#39;loose&#39;</span><span class="p">);</span>     <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;loose&#39;</span>   <span class="c1">// true, looks odd to mix Equality and == in the same line hence the assert capability</span>
</pre></div></p>
<h3 id="equalitynone-a-b">Equality.none( a, b )<a class="headerlink" href="#equalitynone-a-b" title="Permanent link"></a></h3>
<p>Equivalent to <code>Equality.of( a, b, Equality.none )</code>, to confirm <code>a</code> and <code>b</code> are not equal under any of the algorithms.
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">none</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">none</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span> <span class="p">)</span> <span class="c1">// false</span>
</pre></div></p>
<h3 id="equalityall-setarray-methodstrict">Equality.all( &lt;Set/Array>, method=&rsquo;strict&rsquo; )<a class="headerlink" href="#equalityall-setarray-methodstrict" title="Permanent link"></a></h3>
<p>Returns <code>true</code> if all items are equal under the provided method. Parameter <code>method</code> can be provided via reference or name.</p>
<p>An alternative to the laborious <code>a == b &amp;&amp; a == c &amp;&amp; ...</code> or using a <code>Set</code> to consolidate.
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">],</span> <span class="s1">&#39;strict&#39;</span> <span class="p">)</span> <span class="c1">// true; method name</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">],</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">strict</span> <span class="p">)</span> <span class="c1">// true; method reference</span>
</pre></div></p>
<h3 id="equalityany-setarray-methodstrict">Equality.any( &lt;Set/Array>, method=&rsquo;strict&rsquo; )<a class="headerlink" href="#equalityany-setarray-methodstrict" title="Permanent link"></a></h3>
<p>Returns <code>true</code> if at least 2 of the items are equal under the provided method.</p>
<p>An alternative to the laborious <code>a == b || a == c || ...</code> or using a <code>Set</code> to consolidate.
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">],</span> <span class="s1">&#39;loose&#39;</span> <span class="p">)</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">],</span> <span class="s1">&#39;strict&#39;</span> <span class="p">)</span> <span class="c1">// false</span>
</pre></div></p>
<h2 id="equalityhas">Equality.has*<a class="headerlink" href="#equalityhas" title="Permanent link"></a></h2>
<p>These methods let you test the key/value/entry of an <code>Object</code>, <code>Array</code>, <code>Map</code>, or <code>Set</code> using a specific equality algorithm, defaulting to &lsquo;strict&rsquo;. They all return a <code>Boolean</code> as soon as possible.</p>
<p>For the &lsquo;strict&rsquo; case, these methods are effectively aliases for methods like <code>Array.includes</code>, <code>Set.has</code>, but more convenient when iterating over a mixed collection as you wouldn&rsquo;t have to type-check to know which method to use.</p>
<p><strong>Note:</strong> I do not think these methods should be added to the respective data types — having to provide an <code>Equality</code> method already forces you to dip into this API, might as well use it wholly.</p>
<h3 id="equalityhaskey-target-key-methodstrict">Equality.hasKey( target, key, method=&rsquo;strict&rsquo; )<a class="headerlink" href="#equalityhaskey-target-key-methodstrict" title="Permanent link"></a></h3>
<p>Returns whether the target has the provided key, based on the specified equality algorithm. Since keys for <code>Map</code> can be anything, <code>uniform</code> provides a convenient way to match on identical-looking objects at the key level.</p>
<p>For <code>Set</code>/<code>Array</code>, keys are the indices.
<div class="highlight"><pre><span class="c1">// Map</span>
<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span><span class="mi">3</span><span class="p">]</span> <span class="p">]);</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;loose&#39;</span> <span class="p">);</span> <span class="c1">// true</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Object</span>
<span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;1&#39;</span><span class="o">:</span><span class="mi">2</span> <span class="p">}</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">myObj</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loose&#39;</span> <span class="p">);</span> <span class="c1">// true; matches exp &quot;1 in myObj&quot;</span>

<span class="c1">// Set</span>
<span class="kd">let</span> <span class="nx">mySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="p">]);</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">mySet</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loose&#39;</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Array</span>
<span class="kd">let</span> <span class="nx">myArr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">];</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">myArr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loose&#39;</span> <span class="p">);</span> <span class="c1">// true; matches exp &quot;1 in myArr&quot;</span>
</pre></div></p>
<h3 id="equalityhasvalue-target-value-methodstrict">Equality.hasValue( target, value, method=&rsquo;strict&rsquo; )<a class="headerlink" href="#equalityhasvalue-target-value-methodstrict" title="Permanent link"></a></h3>
<p>Returns whether the target has the provided value, based on the specified equality algorithm. Since values for <code>Object</code>/<code>Map</code>/<code>Array</code>/<code>Set</code> can be anything, <code>uniform</code> provides a convenient way to match on identical-looking objects on the value level.
<div class="highlight"><pre><span class="c1">// Map</span>
<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">]);</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span> <span class="c1">// false</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Object</span>
<span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;a&#39;</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">myObj</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Set</span>
<span class="kd">let</span> <span class="nx">mySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span> <span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]);</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">mySet</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Array</span>
<span class="kd">let</span> <span class="nx">myArr</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]</span> <span class="p">];</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">myArr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>
</pre></div></p>
<h3 id="equalityhasentry-target-key-value-methodstrict-method_valuesame-as-method">Equality.hasEntry( target, key, value, method=&rsquo;strict&rsquo;, method_value=&lt;same as method> )<a class="headerlink" href="#equalityhasentry-target-key-value-methodstrict-method_valuesame-as-method" title="Permanent link"></a></h3>
<p>Returns whether the target has the provided key/value pair/entry, each based on the specified equality algorithm. You can provide a second equality algorithm to be used on <code>value</code> instead of using the same from <code>key</code>. Since a <code>Map</code>&lsquo;s <code>key</code> and <code>value</code> can be nearly anything, <code>uniform</code> provides a convenient way to match on identical-looking objects on the key and value level.</p>
<p>For <code>Set</code>/<code>Array</code>, keys are the indices.
<div class="highlight"><pre><span class="c1">// Map</span>
<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">]);</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">hasEntry</span><span class="p">(</span> <span class="nx">myMap</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">);</span> <span class="c1">// true</span>
</pre></div></p>
<h3 id="equalitycustom-name-function-methodtoprecedenone">Equality.custom( name, function, methodToPrecede=&rsquo;none&rsquo; )<a class="headerlink" href="#equalitycustom-name-function-methodtoprecedenone" title="Permanent link"></a></h3>
<p>You can register a custom equality function via unique name.</p>
<p><code>methodToPrecede</code> lets you control the order of tests within <code>Equality.of</code> — specify which algorithm is &lsquo;looser&rsquo; than yours to ensure your test is evaluated before that one.</p>
<p>The function will be given values <code>a</code>, <code>b</code> and should return a <code>boolean</code> (will be coerced). You can leverage <code>Equality</code> and its methods within the function for convenience.</p>
<p>You deregister a custom function by calling this method with the same name and <code>null</code> as the function parameter.</p>
<h4 id="value">Value<a class="headerlink" href="#value" title="Permanent link"></a></h4>
<p>By registering the function, it becomes invocable just like the built-in methods, including the <code>Equality.has*</code> methods. This is intended to make it easy to be consistent across the codebase by conforming to this API.
<div class="highlight"><pre><span class="c1">// register a custom equality function</span>
<span class="nx">Equality</span><span class="p">.</span><span class="nx">custom</span><span class="p">(</span><span class="s1">&#39;combo&#39;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">){</span>
    <span class="c1">// combo is order-agnostic, sort to simulate then use uniform to compare (or DIY)</span>
    <span class="k">return</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">uniform</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">toSorted</span><span class="p">(),</span> <span class="nx">b</span><span class="p">.</span><span class="nx">toSorted</span><span class="p">()</span> <span class="p">);</span>

    <span class="c1">// for .has* methods, a is the key/value/entry item of the target iterable</span>
<span class="p">},</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">uniform</span> <span class="p">);</span>

<span class="c1">// returns custom function&#39;s name</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// combo</span>

<span class="c1">// find combo in set</span>
<span class="kd">let</span> <span class="nx">combo</span>   <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span> <span class="p">];</span>
<span class="kd">let</span> <span class="nx">combos</span>  <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">combos</span><span class="p">,</span> <span class="nx">combo</span><span class="p">,</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">combo</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// find combo in map keys</span>
<span class="kd">let</span> <span class="nx">combos</span>  <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">hasKey</span><span class="p">(</span> <span class="nx">combos</span><span class="p">,</span> <span class="nx">combo</span><span class="p">,</span> <span class="nx">Equality</span><span class="p">.</span><span class="nx">combo</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// true</span>
</pre></div></p>
<h2 id="performance">Performance<a class="headerlink" href="#performance" title="Permanent link"></a></h2>
<h3 id="uniform-algorithm">Uniform Algorithm<a class="headerlink" href="#uniform-algorithm" title="Permanent link"></a></h3>
<p>The <code>uniform</code> algorithm is depth-first recursive. It&rsquo;s not possible to know at runtime if depth-based is more appropriate than breadth-first, as the differences could be deep or wide. It does return as soon as it finds a disqualifier.</p>
<p>Since the algorithms are named, it would be possible to provide a variant under a modified name such as <code>uniform-breadth</code>.</p>
<h3 id="equalityhas-loops">Equality.has* + Loops<a class="headerlink" href="#equalityhas-loops" title="Permanent link"></a></h3>
<p>In the case where a list of items needs to be tested against a collection using <code>uniform</code>, it is recommended to flatten the collection into an <code>Array</code> and use <code>Equality.hasValue</code>. The algorithm does this on invocation, thus a loop would be re-doing it unnecessarily.
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">flatten</span> <span class="o">=</span> <span class="nx">myMap</span><span class="p">.</span><span class="nx">keys</span><span class="p">().</span><span class="nx">toArray</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">found</span>   <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]</span> <span class="p">].</span><span class="nx">find</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
                <span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">(</span> <span class="nx">flatten</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span> <span class="p">)</span>
            <span class="p">});</span>
</pre></div></p>
<h2 id="benefits">Benefits<a class="headerlink" href="#benefits" title="Permanent link"></a></h2>
<ul>
<li>Complex <code>&amp;&amp;</code>/<code>||</code> statements can be replaced with more intuitive <code>Equality.all/any</code> statements. This particularly addresses the common tripping point that <code>a == b == c</code> may not evaluate as expected, whereas <code>Equality.all([a,b,c])</code> likely does.</li>
<li><code>==</code> and <code>===</code> are not objects you can easily bind to structures or storage. With this proposal, you could store the equality by reference or name and evaluate with <code>Equality.test()</code> rather than rolling your own wrappers for each.</li>
<li>Some style guides may prefer the more explicit <code>Equality</code> methods as a defense against typos with <code>==</code>/<code>===</code> — it would presumably be more difficult to mix up <code>loose</code> and <code>strict</code> as words.</li>
<li>Centralizing equality algorithms under an API can help ensure each new algorithm conforms to a standard (name, supported types, etc). It could also reduce pressure to give each new algorithm an equality symbol. This proposal does not contain any, but type/data-structure specific algorithms could be provided.</li>
<li><code>Equality.custom()</code> allows for mixing and matching the algorithms conditionally and to write your own algorithm without writing the overhead logic, similar to the conveniences of <code>Array.sort</code>.</li>
<li>The <a href="https://github.com/tc39/proposal-composites">composites</a> proposal addresses the common use-case of wanting to check an object&rsquo;s membership in a collection, not by reference but when the object is semi/identical to one in the collection. For example, knowing that the structure <code>[0,1]</code> is in <code>[[0,1],[1,2],[2,3]]</code> regardless of references. This proposal solutions that common case out of the box, and <code>Equality.custom</code> allows users to easily write a variation:
<div class="highlight"><pre><span class="nx">Equality</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uniform&#39;</span><span class="p">)</span> <span class="c1">// true</span>
</pre></div></li>
</ul></article></body></html>